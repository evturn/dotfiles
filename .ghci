import Text.Show.Pretty (ppShow)
import qualified Language.Haskell.HsColour as HsColour
import qualified Language.Haskell.HsColour.Colourise as HsColour
import qualified Language.Haskell.HsColour.Output as HsColour
import System.IO

:{
 
let colourPrefs = HsColour.defaultColourPrefs { HsColour.conid = [HsColour.Foreground HsColour.Blue, HsColour.Bold], HsColour.conop = [HsColour.Foreground HsColour.Yellow], HsColour.string = [HsColour.Foreground HsColour.Green], HsColour.char = [HsColour.Foreground HsColour.Green], HsColour.number = [HsColour.Foreground HsColour.Blue, HsColour.Bold], HsColour.layout = [HsColour.Foreground HsColour.Red], HsColour.keyglyph = [HsColour.Foreground HsColour.Red], HsColour.definition = [HsColour.Foreground HsColour.Yellow], HsColour.keyword = [HsColour.Foreground HsColour.Red], HsColour.varid = [HsColour.Foreground HsColour.Red], HsColour.varop = [HsColour.Foreground HsColour.Red], HsColour.cpp = [HsColour.Foreground HsColour.Red], HsColour.variantselection = [HsColour.Foreground HsColour.Red], HsColour.selection = [HsColour.Foreground HsColour.Yellow] }
:}

cterm = putStrLn . HsColour.hscolour (HsColour.TTYg HsColour.XTerm256Compatible) colourPrefs False False "" False . ppShow

:set -interactive-print=cterm

:def clear const . return $ ":! clear"
:def lc const . return $ ":script ~/.ghci"

:set prompt "\ESC[1;32mÎ»> \ESC[0m\STX"
